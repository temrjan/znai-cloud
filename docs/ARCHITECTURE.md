# ĞÑ€Ñ…Ğ¸Ñ‚ĞµĞºÑ‚ÑƒÑ€Ğ° AI-Avangard

## ğŸ¯ ĞŸÑ€Ğ¸Ğ½Ñ†Ğ¸Ğ¿Ñ‹ Ñ€Ğ°Ğ·Ñ€Ğ°Ğ±Ğ¾Ñ‚ĞºĞ¸

### 1. **Mobile-First Design** ğŸ”¥
**ĞšÑ€Ğ¸Ñ‚Ğ¸Ñ‡ĞµÑĞºĞ¸Ğ¹ Ğ¿Ñ€Ğ¸Ğ¾Ñ€Ğ¸Ñ‚ĞµÑ‚**: Ğ’ÑĞµ ĞºĞ¾Ğ¼Ğ¿Ğ¾Ğ½ĞµĞ½Ñ‚Ñ‹ Ñ€Ğ°Ğ·Ñ€Ğ°Ğ±Ğ°Ñ‚Ñ‹Ğ²Ğ°ÑÑ‚ÑÑ ÑĞ½Ğ°Ñ‡Ğ°Ğ»Ğ° Ğ´Ğ»Ñ Ğ¼Ğ¾Ğ±Ğ¸Ğ»ÑŒĞ½Ñ‹Ñ… ÑƒÑÑ‚Ñ€Ğ¾Ğ¹ÑÑ‚Ğ², Ğ·Ğ°Ñ‚ĞµĞ¼ Ğ°Ğ´Ğ°Ğ¿Ñ‚Ğ¸Ñ€ÑƒÑÑ‚ÑÑ Ğ´Ğ»Ñ Ğ´ĞµÑĞºÑ‚Ğ¾Ğ¿Ğ°.

**Breakpoints:**
```css
mobile:  320px - 768px   (primary target)
tablet:  768px - 1024px
desktop: 1024px+         (enhancement)
```

**Ğ¢Ñ€ĞµĞ±Ğ¾Ğ²Ğ°Ğ½Ğ¸Ñ:**
- âœ… Touch-friendly ĞºĞ½Ğ¾Ğ¿ĞºĞ¸ (min 44px)
- âœ… Ğ§Ğ¸Ñ‚Ğ°ĞµĞ¼Ñ‹Ğµ ÑˆÑ€Ğ¸Ñ„Ñ‚Ñ‹ Ğ½Ğ° Ğ¼Ğ°Ğ»Ñ‹Ñ… ÑĞºÑ€Ğ°Ğ½Ğ°Ñ…
- âœ… Hamburger menu Ğ´Ğ»Ñ Ğ½Ğ°Ğ²Ğ¸Ğ³Ğ°Ñ†Ğ¸Ğ¸
- âœ… ĞĞ¿Ñ‚Ğ¸Ğ¼Ğ¸Ğ·Ğ°Ñ†Ğ¸Ñ Ğ·Ğ°Ğ³Ñ€ÑƒĞ·ĞºĞ¸ (lazy loading)
- âœ… Ğ¢ĞµÑÑ‚Ğ¸Ñ€Ğ¾Ğ²Ğ°Ğ½Ğ¸Ğµ Ğ½Ğ° Ñ€ĞµĞ°Ğ»ÑŒĞ½Ñ‹Ñ… ÑƒÑÑ‚Ñ€Ğ¾Ğ¹ÑÑ‚Ğ²Ğ°Ñ…

### 2. Clean Architecture
- Ğ Ğ°Ğ·Ğ´ĞµĞ»ĞµĞ½Ğ¸Ğµ Ğ½Ğ° ÑĞ»Ğ¾Ğ¸ (routes â†’ services â†’ models)
- Dependency Injection
- Ğ•Ğ´Ğ¸Ğ½Ğ°Ñ Ğ¾Ñ‚Ğ²ĞµÑ‚ÑÑ‚Ğ²ĞµĞ½Ğ½Ğ¾ÑÑ‚ÑŒ ĞºĞ»Ğ°ÑÑĞ¾Ğ²

### 3. Test-Driven Development
- Unit tests: 80%+ coverage
- Integration tests Ğ´Ğ»Ñ ĞºÑ€Ğ¸Ñ‚Ğ¸Ñ‡ĞµÑĞºĞ¸Ñ… Ğ¿ÑƒÑ‚ĞµĞ¹
- E2E tests Ğ´Ğ»Ñ Ğ¾ÑĞ½Ğ¾Ğ²Ğ½Ñ‹Ñ… ÑÑ†ĞµĞ½Ğ°Ñ€Ğ¸ĞµĞ²

### 4. Ğ‘ĞµĞ·Ğ¾Ğ¿Ğ°ÑĞ½Ğ¾ÑÑ‚ÑŒ
- Zero-trust: Ğ¿Ñ€Ğ¾Ğ²ĞµÑ€ĞºĞ° Ğ½Ğ° ĞºĞ°Ğ¶Ğ´Ğ¾Ğ¼ ÑƒÑ€Ğ¾Ğ²Ğ½Ğµ
- Ğ˜Ğ·Ğ¾Ğ»ÑÑ†Ğ¸Ñ Ğ´Ğ°Ğ½Ğ½Ñ‹Ñ… Ğ¿Ğ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ñ‚ĞµĞ»ĞµĞ¹
- Rate limiting

---

## ğŸ—ï¸ ĞÑ€Ñ…Ğ¸Ñ‚ĞµĞºÑ‚ÑƒÑ€Ğ° Backend

### Ğ¡Ñ‚Ñ€ÑƒĞºÑ‚ÑƒÑ€Ğ° ÑĞ»Ğ¾ĞµĞ²

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚     Routes (API Endpoints)          â”‚  â† HTTP handlers
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚     Middleware (Auth, RateLimit)    â”‚  â† Cross-cutting concerns
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚     Services (Business Logic)       â”‚  â† Core logic
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚     Models (Data Layer)             â”‚  â† Database ORM
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### ĞšĞ¾Ğ¼Ğ¿Ğ¾Ğ½ĞµĞ½Ñ‚Ñ‹

#### 1. Routes (API Layer)
**Responsibility**: HTTP request handling, validation, response formatting

```python
# backend/app/routes/chat.py
@router.post("/chat", response_model=ChatResponse)
async def chat(
    request: ChatRequest,
    user: User = Depends(get_current_user)
):
    """
    RAG chat endpoint
    - Validates request
    - Delegates to ChatService
    - Returns formatted response
    """
    return await chat_service.process_query(user.id, request.message)
```

#### 2. Services (Business Logic Layer)
**Responsibility**: Core business logic, orchestration

```python
# backend/app/services/chat_service.py
class ChatService:
    def __init__(
        self,
        qdrant: QdrantService,
        llm: LLMService,
        quota: QuotaService
    ):
        self.qdrant = qdrant
        self.llm = llm
        self.quota = quota

    async def process_query(self, user_id: int, query: str):
        # 1. Check quota
        await self.quota.check_and_increment(user_id)

        # 2. Search vectors (with user isolation)
        results = await self.qdrant.search(
            query=query,
            filter={"user_id": user_id}
        )

        # 3. Generate answer
        answer = await self.llm.generate(
            context=[r.text for r in results],
            question=query
        )

        return ChatResponse(answer=answer, sources=results)
```

#### 3. Models (Data Layer)
**Responsibility**: Database schema, ORM

```python
# backend/app/models/user.py
class User(Base):
    __tablename__ = "users"

    id = Column(Integer, primary_key=True)
    email = Column(String(255), unique=True, nullable=False)
    password_hash = Column(String(255), nullable=False)
    status = Column(Enum(UserStatus), default=UserStatus.PENDING)

    # Relationships
    quota = relationship("UserQuota", back_populates="user", uselist=False)
    documents = relationship("Document", back_populates="user")
```

### Dependency Injection

```python
# backend/app/dependencies.py
def get_qdrant_service() -> QdrantService:
    return QdrantService(
        client=qdrant_client,
        collection_name=settings.QDRANT_COLLECTION
    )

def get_chat_service(
    qdrant: QdrantService = Depends(get_qdrant_service),
    llm: LLMService = Depends(get_llm_service)
) -> ChatService:
    return ChatService(qdrant=qdrant, llm=llm)
```

---

## ğŸ¨ ĞÑ€Ñ…Ğ¸Ñ‚ĞµĞºÑ‚ÑƒÑ€Ğ° Frontend (Mobile-First)

### Component Hierarchy

```
App
â”œâ”€â”€ ThemeProvider (Primer)
â”œâ”€â”€ AuthProvider (Context)
â””â”€â”€ AppLayout
    â”œâ”€â”€ Header (fixed, mobile-friendly)
    â”‚   â”œâ”€â”€ Logo
    â”‚   â”œâ”€â”€ HamburgerMenu (mobile)
    â”‚   â””â”€â”€ UserMenu
    â”œâ”€â”€ Sidebar (collapsible)
    â”‚   â”œâ”€â”€ NavList
    â”‚   â””â”€â”€ QuotaBadge
    â””â”€â”€ PageContent (responsive)
        â”œâ”€â”€ ChatPage
        â”œâ”€â”€ DocumentsPage
        â””â”€â”€ AdminPage
```

### Mobile-First CSS Strategy

```typescript
// frontend/src/styles/responsive.ts
export const breakpoints = {
  mobile: '320px',
  tablet: '768px',
  desktop: '1024px'
}

// Mobile-first media queries
export const media = {
  tablet: `@media (min-width: ${breakpoints.tablet})`,
  desktop: `@media (min-width: ${breakpoints.desktop})`
}

// Usage:
const Container = styled(Box)`
  /* Mobile (default) */
  padding: 12px;
  font-size: 14px;

  /* Tablet */
  ${media.tablet} {
    padding: 16px;
    font-size: 16px;
  }

  /* Desktop */
  ${media.desktop} {
    padding: 24px;
    max-width: 1200px;
  }
`
```

### Primer React Responsive Components

```typescript
// Primer Ğ°Ğ²Ñ‚Ğ¾Ğ¼Ğ°Ñ‚Ğ¸Ñ‡ĞµÑĞºĞ¸ Ğ°Ğ´Ğ°Ğ¿Ñ‚Ğ¸Ğ²ĞµĞ½
<PageLayout>
  {/* Sidebar ÑĞºÑ€Ñ‹Ğ²Ğ°ĞµÑ‚ÑÑ Ğ½Ğ° mobile */}
  <PageLayout.Pane
    position="start"
    hidden={{ narrow: true }}  // â† ÑĞºÑ€Ñ‹Ñ‚ Ğ½Ğ° mobile
  >
    <Sidebar />
  </PageLayout.Pane>

  {/* Content Ğ°Ğ´Ğ°Ğ¿Ñ‚Ğ¸Ñ€ÑƒĞµÑ‚ÑÑ */}
  <PageLayout.Content>
    <Chat />
  </PageLayout.Content>
</PageLayout>

// Responsive Header
<Header>
  {/* Mobile: HamburgerMenu */}
  <Header.Item sx={{ display: ['block', 'none'] }}>
    <IconButton icon={ThreeBarsIcon} />
  </Header.Item>

  {/* Desktop: Full nav */}
  <Header.Item sx={{ display: ['none', 'block'] }}>
    <NavList />
  </Header.Item>
</Header>
```

### Touch-Friendly UI

```typescript
// ĞœĞ¸Ğ½Ğ¸Ğ¼Ğ°Ğ»ÑŒĞ½Ñ‹Ğµ Ñ€Ğ°Ğ·Ğ¼ĞµÑ€Ñ‹ Ğ´Ğ»Ñ touch
const TOUCH_TARGET_SIZE = 44; // px (Apple HIG)

<Button
  sx={{
    minWidth: TOUCH_TARGET_SIZE,
    minHeight: TOUCH_TARGET_SIZE,
    fontSize: ['14px', '16px'] // mobile, desktop
  }}
>
  Send
</Button>
```

---

## ğŸ” Ğ‘ĞµĞ·Ğ¾Ğ¿Ğ°ÑĞ½Ğ¾ÑÑ‚ÑŒ: Multi-Tenancy Isolation

### Ğ˜Ğ·Ğ¾Ğ»ÑÑ†Ğ¸Ñ Ğ´Ğ°Ğ½Ğ½Ñ‹Ñ…

**Ğ£Ñ€Ğ¾Ğ²ĞµĞ½ÑŒ 1: Middleware**
```python
@app.middleware("http")
async def enforce_user_context(request: Request, call_next):
    # Ğ˜Ğ·Ğ²Ğ»ĞµĞºĞ°ĞµĞ¼ user_id Ğ¸Ğ· JWT
    user_id = get_user_id_from_token(request)

    # Ğ”Ğ¾Ğ±Ğ°Ğ²Ğ»ÑĞµĞ¼ Ğ² request state
    request.state.user_id = user_id

    return await call_next(request)
```

**Ğ£Ñ€Ğ¾Ğ²ĞµĞ½ÑŒ 2: Service Layer**
```python
class QdrantService:
    async def search(self, query: str, user_id: int):
        # ĞĞ‘Ğ¯Ğ—ĞĞ¢Ğ•Ğ›Ğ¬ĞĞĞ¯ Ñ„Ğ¸Ğ»ÑŒÑ‚Ñ€Ğ°Ñ†Ğ¸Ñ
        filter_condition = models.Filter(
            must=[
                models.FieldCondition(
                    key="user_id",
                    match=models.MatchValue(value=user_id)
                )
            ]
        )

        return await self.client.search(
            collection_name=self.collection,
            query_vector=embed(query),
            query_filter=filter_condition  # â† Ğ˜Ğ—ĞĞ›Ğ¯Ğ¦Ğ˜Ğ¯
        )
```

**Ğ£Ñ€Ğ¾Ğ²ĞµĞ½ÑŒ 3: Database**
```sql
-- Row-Level Security (PostgreSQL)
CREATE POLICY user_documents_policy ON documents
    USING (user_id = current_setting('app.current_user_id')::int);
```

---

## ğŸ“Š Data Flow

### Ğ—Ğ°Ğ¿Ñ€Ğ¾Ñ Ğº RAG (User Query)

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ User (mobileâ”‚
â”‚  browser)   â”‚
â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”˜
       â”‚ POST /chat {message}
       â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Nginx (SSL termination)     â”‚
â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
       â”‚
       â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ FastAPI Middleware          â”‚
â”‚ - Extract JWT               â”‚
â”‚ - Validate user_id          â”‚
â”‚ - Rate limiting check       â”‚
â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
       â”‚
       â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ ChatService                 â”‚
â”‚ 1. Check quota              â”‚
â”‚ 2. Search Qdrant (filtered) â”‚
â”‚ 3. Generate answer (OpenAI) â”‚
â”‚ 4. Log query                â”‚
â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
       â”‚
       â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Response (JSON)             â”‚
â”‚ {                           â”‚
â”‚   answer: "...",            â”‚
â”‚   sources: [...],           â”‚
â”‚   quota: {used: 15, limit: 100} â”‚
â”‚ }                           â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### Ğ—Ğ°Ğ³Ñ€ÑƒĞ·ĞºĞ° Ğ´Ğ¾ĞºÑƒĞ¼ĞµĞ½Ñ‚Ğ° (Upload Flow)

```
User uploads file (mobile)
    â†“
Frontend: Validate (size, type)
    â†“
POST /documents/upload
    â†“
Backend:
    1. Check quota (5/5?)
    2. Save file â†’ /data/users/{user_id}/
    3. Calculate hash (deduplication)
    4. Split into chunks
    5. Generate embeddings (OpenAI)
    6. Store in Qdrant (with user_id)
    7. Update PostgreSQL
    8. Increment quota
    â†“
Response: {doc_id, chunks_count, quota}
```

---

## ğŸ§ª Ğ¢ĞµÑÑ‚Ğ¸Ñ€Ğ¾Ğ²Ğ°Ğ½Ğ¸Ğµ

### Backend Test Strategy

**1. Unit Tests (80%+ coverage)**
```python
# tests/unit/test_chat_service.py
@pytest.mark.asyncio
async def test_chat_service_enforces_user_isolation(mock_qdrant):
    service = ChatService(qdrant=mock_qdrant, llm=mock_llm)

    await service.process_query(user_id=1, query="test")

    # ĞŸÑ€Ğ¾Ğ²ĞµÑ€ÑĞµĞ¼ Ñ‡Ñ‚Ğ¾ Ñ„Ğ¸Ğ»ÑŒÑ‚Ñ€ Ğ¿Ñ€Ğ¸Ğ¼ĞµĞ½Ñ‘Ğ½
    mock_qdrant.search.assert_called_once()
    call_args = mock_qdrant.search.call_args
    assert call_args.kwargs['filter']['must'][0]['key'] == 'user_id'
    assert call_args.kwargs['filter']['must'][0]['match']['value'] == 1
```

**2. Integration Tests**
```python
# tests/integration/test_rag_flow.py
async def test_full_rag_flow(client, test_user, test_document):
    # 1. Upload document
    response = await client.post(
        "/documents/upload",
        files={"file": test_document},
        headers={"Authorization": f"Bearer {test_user.token}"}
    )
    assert response.status_code == 200

    # 2. Wait for indexing
    await asyncio.sleep(2)

    # 3. Query RAG
    response = await client.post(
        "/chat",
        json={"message": "test query"},
        headers={"Authorization": f"Bearer {test_user.token}"}
    )

    assert response.status_code == 200
    assert "answer" in response.json()
```

### Frontend Test Strategy

**1. Component Tests (Vitest + Testing Library)**
```typescript
// tests/components/ChatMessage.test.tsx
import { render, screen } from '@testing-library/react'
import { ChatMessage } from '@/components/ChatMessage'

describe('ChatMessage (Mobile)', () => {
  it('renders correctly on mobile viewport', () => {
    // Set mobile viewport
    global.innerWidth = 375

    render(<ChatMessage text="Hello" sender="user" />)

    const message = screen.getByText('Hello')
    expect(message).toBeInTheDocument()

    // Check mobile-specific styles
    expect(message).toHaveStyle({ fontSize: '14px' })
  })
})
```

**2. Responsive Tests**
```typescript
describe('AppLayout responsiveness', () => {
  it('shows hamburger menu on mobile', () => {
    render(<AppLayout />, { viewport: 'mobile' })
    expect(screen.getByLabelText('Menu')).toBeVisible()
  })

  it('shows full sidebar on desktop', () => {
    render(<AppLayout />, { viewport: 'desktop' })
    expect(screen.getByRole('navigation')).toBeVisible()
  })
})
```

---

## ğŸ“ˆ Performance Optimization

### Backend
- âœ… Connection pooling (PostgreSQL, Redis)
- âœ… Async I/O (asyncio, aiohttp)
- âœ… Response caching (Redis)
- âœ… Database indexing (user_id, email)

### Frontend (Mobile-First)
- âœ… Code splitting (Vite)
- âœ… Lazy loading ĞºĞ¾Ğ¼Ğ¿Ğ¾Ğ½ĞµĞ½Ñ‚Ğ¾Ğ²
- âœ… Image optimization (WebP, lazy load)
- âœ… ĞœĞ¸Ğ½Ğ¸Ğ¼Ğ¸Ğ·Ğ°Ñ†Ğ¸Ñ bundle size
- âœ… Service Worker (offline support)

### Metrics
```
Target (Mobile 4G):
- First Contentful Paint: < 1.8s
- Time to Interactive: < 3.8s
- Lighthouse Score: > 90
```

---

## ğŸ”„ CI/CD Pipeline (Ğ±ÑƒĞ´ÑƒÑ‰ĞµĞµ)

```yaml
# .github/workflows/main.yml
on: [push, pull_request]

jobs:
  backend-tests:
    - Run pytest
    - Coverage > 80%
    - Linting (black, flake8, mypy)

  frontend-tests:
    - Run vitest
    - Coverage > 70%
    - Linting (eslint, prettier)
    - Mobile viewport tests

  build:
    - Build Docker images
    - Push to registry

  deploy:
    - Deploy to staging
    - Run smoke tests
    - Deploy to production
```

---

## ğŸ“± Mobile-Specific Considerations

### 1. Touch Gestures
```typescript
// Swipe to delete document
<Swipeable
  onSwipeLeft={() => confirmDelete(doc.id)}
  threshold={100}
>
  <DocumentCard doc={doc} />
</Swipeable>
```

### 2. Offline Support
```typescript
// Service Worker for offline caching
if ('serviceWorker' in navigator) {
  navigator.serviceWorker.register('/sw.js')
}

// Cache API responses
cache.put(request, response.clone())
```

### 3. Network Optimization
```typescript
// Detect connection type
if (navigator.connection?.effectiveType === '4g') {
  // Load high-quality images
} else {
  // Load optimized images
}
```

---

**Version**: 1.0.0
**Last Updated**: 2025-11-20
